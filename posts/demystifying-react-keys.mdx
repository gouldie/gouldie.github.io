---
slug: demystifying-react-keys
title: 'Demystifying React Keys'
subtitle: Why using an index is sometimes not enough
description:
  Why do we need to provide a key prop anyway? What happens if we don't? When is it a bad idea to
  simply use the index?
---

# Demystifying React Keys

## Why using an index is sometimes not enough

```
Warning: Each child in a list should have a unique "key" prop.
```

If you're familiar with React, you've probably come across this warning before. It occurs when
attempting to render a list dynamically without providing a key to each list item.

So, provide a key, and the warning disappears. Problem solved? Not always.

In order to fully understand why, it's import to first understand
React's&nbsp;<a href='https://legacy.reactjs.org/docs/reconciliation.html' target='_blank'>Reconciliation</a>
process.

### Reconciliation

Reconciliation is the term used to describe the process in which React updates the browser DOM
whenever state or props change.

In this process, React will re-render, and then compare the previous component tree to the current
component tree (known as diffing) to determine the changes that need to be applied to the browser
DOM.

While diffing, React uses element type and order to determine whether an element (or component)
needs to be updated. If an element needs to be updated, it will be created (mounted) from scratch.

### Why are keys required?

Without keys, React can't track the position of an element from one render to the next.

This is most common with lists - user applies a filter, list order changes.

React would be forced to re-create all list items on each render, which is not only computationally
expensive, but would also reset any underlying state.

Take this example of a list that you are asking React to render using the `map` function:

```js
<li>ğŸ Bread. Stock: 5</li>
<li>ğŸ¥š Eggs. Stock: 3</li>
<li>ğŸ¥› Milk. Stock: 4</li>
```

Now, let's pretend the user deletes the first element, ğŸ.

```js
<li>ğŸ¥š Eggs. Stock: 3</li>
<li>ğŸ¥› Milk. Stock: 4</li>
```

We know that ğŸ was simply deleted and the rest shifted up. But React does not. It cannot know
whether ğŸ was deleted, or whether ğŸ¥š was deleted and ğŸ renamed to ğŸ¥š, or whether ğŸ¥› was swapped
with ğŸ, ğŸ¥› renamed to ğŸ¥š and ğŸ¥š renamed to ğŸ¥›.

This might not seem like a big deal, but in a real application, each of these list items would
likely have some underlying state, and making the wrong assumption could lead to unintended
side-effects.

### Enter the key prop

The `key` prop allows the developer to give React a hint as to which list item is which.

Using the same example, but with a key:

```js
<li key="bread">ğŸ Bread. Stock: 5</li>
<li key="eggs">ğŸ¥š Eggs. Stock: 3</li>
<li key="milk">ğŸ¥› Milk. Stock: 4</li>
```

Let's say the user deletes the ğŸ¥š this time.

```js
<li key="bread">ğŸ Bread. Stock: 5</li>
<li key="milk">ğŸ¥› Milk. Stock: 4</li>
```

React knows the second element was deleted, because the key is now gone. As a result React can
perform the re-render much more efficiently.

If you don't provide a key, React will take the index by default.

### Why using an index is sometimes not enough

Using an index as a key _will_ suppress Reacts warning, however, it can produce unintended
side-effects if the list can change (re-order, add or remove elements).

Using the same example, with an index as a key:

```js
<li key={0}>ğŸ Bread. Stock: 5</li>
<li key={1}>ğŸ¥š Eggs. Stock: 3</li>
<li key={2}>ğŸ¥› Milk. Stock: 4</li>
```

User deletes the second element, ğŸ¥š.

```js
<li key={0}>ğŸ Bread. Stock: 5</li>
<li key={1}>ğŸ¥š Eggs. Stock: 3</li>
```

When ğŸ¥š was deleted, ğŸ¥› took over position 2 (index 1) in the array, and therefore key 1. In other
words, React thinks ğŸ¥› was deleted because key 2 no longer exists.

This funky behaviour _can_ depend on your implementation, but generally it's best not to mess around
and simply provide React a key that meets the following criteria:

- It must be stable (not change during the lifetime of the component)
- It must be unique within the list

### Try it yourself

Here is a simple stock management app. It displays a list of products and the number of stock
available for each one. It has two main features:

- The user can update the stock for a particular product
- The user can shuffle the order of the products

Unfortunately, the developer used the product index as the key for each `<Product />`. As a result,
shuffling doesn't work as expected. Can you fix it?

<StockManagement />

Hint: you'll need to find (or create) a unique identifier for each product, and assign that as the
`<Product />` key.
